<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Viewer – Warmtekamer</title>
  <style>
    html,body {height:100%; margin:0; background:#0c0f14; color:#e6e6e6; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #app {position:fixed; inset:0}
    canvas {display:block}
    .hud {
      position: fixed; left: 16px; bottom: 16px; z-index: 10;
      background: rgba(20,24,33,.6); backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 12px 14px; max-width: 380px
    }
    .hud h1 {font-size: 14px; margin:0 0 6px 0; font-weight: 600}
    .hud p {font-size: 12px; margin: 0; line-height: 1.45; color:#cfd6e4}
    .topbar {
      position: fixed; right: 16px; top: 16px; z-index: 10; display:flex; gap:8px; flex-wrap:wrap
    }
    button {
      font: inherit; font-weight: 600; letter-spacing: .2px;
      background: #1a2131; color:#e6eefc; border:1px solid #2b3a58;
      border-radius: 10px; padding: 8px 12px; cursor: pointer
    }
    button:hover { filter: brightness(1.1) }
    .badge {
      position: fixed; left: 16px; top: 16px; z-index: 10;
      font-size: 12px; color:#a9b7d9; opacity:.9
    }
    .loader { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:5; pointer-events:none; }
    .loader .bubble {
      width: 12px; height: 12px; margin: 0 6px; border-radius: 50%; background:#cfe1ff; opacity:.85;
      animation: b 1s infinite ease-in-out
    }
    .loader .bubble:nth-child(2){animation-delay:.15s} .loader .bubble:nth-child(3){animation-delay:.3s}
    @keyframes b { 0%, 80%, 100% { transform: scale(0) } 40% { transform: scale(1) } }
    a.hint { color:#9cc0ff; text-decoration: none; border-bottom:1px dashed #4669b8 }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="badge">3D Viewer • Orbit: sleep/drag • Zoom: scroll • Pan: right-drag</div>

  <div class="topbar">
    <button id="resetBtn" title="Reset camera">Reset view</button>
    <button id="wireBtn" title="Toon/Verberg draadframe">Wireframe</button>
    <button id="fitBtn" title="Fit to view">Fit to view</button>
  </div>

  <div class="hud">
    <h1>Warmtekamer – 3D viewer</h1>
    <p>
      Sleep om te draaien · Scroll om te zoomen · Rechtsklik om te pannen.<br/>
      Dit is een <em>read-only</em> viewer (geen uploads).<br/>
      Tip: voeg <code>?file=models/warmtekamer.stl</code> toe aan de URL om een ander bestand te tonen.
    </p>
  </div>

  <div class="loader" id="loader" aria-hidden="true">
    <div class="bubble"></div><div class="bubble"></div><div class="bubble"></div>
  </div>

  <!-- Three.js (module build) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { STLLoader }    from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/STLLoader.js';
    import { GLTFLoader }   from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'https://unpkg.com/three@0.160.1/examples/jsm/environments/RoomEnvironment.js';

    // ---------- Config ----------
    const DEFAULT_MODEL = 'models/warmtekamer.stl'; // Zet hier jouw standaardbestand
    // Je kunt via ?file=pad/naar/model.stl of .glb een ander bestand tonen
    const url = new URL(location.href);
    const modelPath = url.searchParams.get('file') || DEFAULT_MODEL;

    // ---------- Scene ----------
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0f14);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 10_000);
    camera.position.set(2.8, 1.8, 2.8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.05;
    controls.maxDistance = 1000;

    // Soft, nette belichting
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.05).texture;

    // Extra licht voor wat contrast
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 8, 4);
    scene.add(dir);

    // Schaduwvrije "stage" (optioneel, licht reflectie-look)
    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(3.2, 64),
      new THREE.MeshStandardMaterial({ color: 0x0b0e13, metalness: 0.0, roughness: 0.9 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.0001;
    floor.receiveShadow = false;
    scene.add(floor);

    // ---------- Loading ----------
    const loaderEl = document.getElementById('loader');
    const showLoader = (v) => loaderEl.style.display = v ? 'flex' : 'none';
    showLoader(true);

    const root = new THREE.Group();
    scene.add(root);

    // ---------- Helpers ----------
    function computeBounds(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      const radius = Math.max(size.x, size.y, size.z) * 0.5;
      return { box, size, center, radius: Math.max(radius, 1e-6) };
    }

    function fitCamera(obj, pad = 1.3) {
      const { center, radius } = computeBounds(obj);
      controls.target.copy(center);

      const fov = camera.fov * (Math.PI/180);
      const dist = (radius * pad) / Math.sin(fov / 2);
      const dirVec = new THREE.Vector3(1, 0.6, 1).normalize(); // prettige schuine hoek
      camera.position.copy(center).addScaledVector(dirVec, dist);
      camera.near = Math.max(dist / 1000, 0.001);
      camera.far  = dist * 50 + radius * 10;
      camera.updateProjectionMatrix();
      controls.update();
    }

    function centerPivot(obj) {
      const { center } = computeBounds(obj);
      obj.position.sub(center);
    }

    function makeMaterial() {
      return new THREE.MeshStandardMaterial({
        color: 0xbec7d5,
        metalness: 0.15,
        roughness: 0.35
      });
    }

    let currentMaterial = makeMaterial();
    let wireframeOn = false;

    function applyMaterial(obj, material) {
      obj.traverse((c) => {
        if (c.isMesh) {
          c.material = material;
          c.castShadow = false; c.receiveShadow = false;
        }
      });
    }

    async function loadSTL(path) {
      const loader = new STLLoader();
      return new Promise((resolve, reject) => {
        loader.load(path, (geom) => {
          if (!geom.hasAttribute('normal')) {
            geom.computeVertexNormals();
          }
          const mesh = new THREE.Mesh(geom, currentMaterial);
          mesh.name = 'STLMesh';
          resolve(mesh);
        }, undefined, reject);
      });
    }

    async function loadGLTF(path) {
      const loader = new GLTFLoader();
      return new Promise((resolve, reject) => {
        loader.load(path, (gltf) => resolve(gltf.scene), undefined, reject);
      });
    }

    function setWireframe(enabled) {
      wireframeOn = enabled;
      root.traverse((c) => {
        if (c.isMesh && c.material) {
          if (Array.isArray(c.material)) {
            c.material.forEach(m => m.wireframe = enabled);
          } else {
            c.material.wireframe = enabled;
          }
        }
      });
    }

    // ---------- Load model ----------
    (async () => {
      try {
        const ext = modelPath.split('.').pop().toLowerCase();
        let model;

        if (ext === 'stl')       model = await loadSTL(modelPath);
        else if (ext === 'glb' || ext === 'gltf') model = await loadGLTF(modelPath);
        else throw new Error(`Bestandstype niet ondersteund: .${ext}\nGebruik .stl (aanbevolen) of .glb/.gltf.`);

        root.add(model);
        centerPivot(root);
        applyMaterial(root, currentMaterial);
        fitCamera(root, 1.4);
      } catch (err) {
        console.error(err);
        alert(err.message || err);
      } finally {
        showLoader(false);
      }
    })();

    // ---------- UI ----------
    document.getElementById('resetBtn').onclick = () => fitCamera(root, 1.4);
    document.getElementById('wireBtn').onclick  = () => setWireframe(!wireframeOn);
    document.getElementById('fitBtn').onclick   = () => fitCamera(root, 1.2);

    // ---------- Render loop ----------
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
