<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
  import { STLLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/STLLoader.js';
  import { ThreeMFLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/3MFLoader.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/DRACOLoader.js';
  import { RoomEnvironment } from 'https://unpkg.com/three@0.160.1/examples/jsm/environments/RoomEnvironment.js';

  const DEFAULT_MODEL = 'models/warmtekamer.3mf'; // <-- jouw Fusion export

  // ... (je bestaande scene/camera/controls/env code blijft hetzelfde)

  // Helpers die je al had:
  // - computeBounds / fitCamera / centerPivot
  // - normalizeScale (brengt extreem groot/klein naar normale maat)
  // - applyMaterial (maar pas op dat we 3MF-kleuren niet overschrijven)

  async function loadSTL(path) {
    const loader = new STLLoader();
    return new Promise((resolve, reject) => {
      loader.load(path, (geom) => {
        if (!geom.hasAttribute('normal')) geom.computeVertexNormals();
        const mesh = new THREE.Mesh(geom);
        resolve(mesh);
      }, undefined, reject);
    });
  }

  async function load3MF(path) {
    const loader = new ThreeMFLoader();
    return new Promise((resolve, reject) => {
      loader.load(path, (obj) => resolve(obj), undefined, reject);
    });
  }

  async function loadGLB(path) {
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://unpkg.com/three@0.160.1/examples/jsm/libs/draco/');
    loader.setDRACOLoader(draco);
    return new Promise((resolve, reject) => {
      loader.load(path, (gltf) => resolve(gltf.scene), undefined, reject);
    });
  }

  (async () => {
    const ext = DEFAULT_MODEL.split('.').pop().toLowerCase();
    let model;
    if (ext === '3mf')      model = await load3MF(DEFAULT_MODEL);
    else if (ext === 'stl') model = await loadSTL(DEFAULT_MODEL);
    else if (ext === 'glb' || ext === 'gltf') model = await loadGLB(DEFAULT_MODEL);
    else throw new Error('Niet-ondersteund type. Gebruik .3mf / .stl / .glb');

    // 3MF heeft vaak al kleuren/materialen â€” laat die staan.
    // Voor STL: geef een standaardmateriaal.
    if (ext === 'stl') {
      const mat = new THREE.MeshStandardMaterial({ color: 0xbec7d5, metalness: 0.15, roughness: 0.35, side: THREE.DoubleSide });
      model.traverse(o => { if (o.isMesh) o.material = mat; });
    } else {
      // Zorg dat alle meshes zichtbaar zijn en netjes renderen
      model.traverse(o => { if (o.isMesh) { o.castShadow = false; o.receiveShadow = false; }});
    }

    // Voeg toe en schaal/center/fit
    const root = new THREE.Group();
    scene.add(root);
    root.add(model);

    // 3MF komt vrijwel altijd in millimeters: schaal naar meters
    if (ext === '3mf') root.scale.setScalar(0.001);

    // Normaliseer maat (voor zekerheid), center en fit
    normalizeScale(root, 1.0);
    centerPivot(root);
    fitCamera(root, 1.4);

    // ... (render-loop & resize handler zoals je al had)
  })();
</script>
