<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Warmtekamer – 3D Viewer (STL, robuust)</title>
<style>
  html,body{height:100%;margin:0;background:#0c0f14;color:#e6e6e6;font-family:system-ui,Segoe UI,Roboto,Arial}
  #app{position:fixed;inset:0} .ui{position:fixed;top:12px;right:12px;display:flex;gap:8px;z-index:10}
  button{background:#1a2131;color:#e6eefc;border:1px solid #2b3a58;border-radius:10px;padding:8px 12px;cursor:pointer}
  .hint{position:fixed;left:12px;bottom:12px;font-size:12px;color:#a9b7d9}
</style>
</head>
<body>
<div id="app"></div>
<div class="ui">
  <button id="fit">Fit view</button>
  <button id="wire">Wireframe</button>
</div>
<div class="hint">Sleep = draaien · Scroll = zoomen · Rechtsklik = pannen</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
import { STLLoader }     from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/STLLoader.js';
import { RoomEnvironment } from 'https://unpkg.com/three@0.160.1/examples/jsm/environments/RoomEnvironment.js';

const MODEL = 'models/warmtekamer.stl';   // <-- jouw bestand

// Renderer / scene / camera
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.75));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0c0f14);
const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.001, 100000);
camera.position.set(2.8,1.8,2.8);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const env = new THREE.PMREMGenerator(renderer);
scene.environment = env.fromScene(new RoomEnvironment(), 0.05).texture;
scene.add(new THREE.HemisphereLight(0xffffff,0x111122,0.6));
const dl = new THREE.DirectionalLight(0xffffff,0.9); dl.position.set(5,8,4); scene.add(dl);

const root = new THREE.Group(); scene.add(root);
let wire = false;

function bounds(obj){
  const b = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(), center = new THREE.Vector3();
  b.getSize(size); b.getCenter(center);
  return { b, size, center, radius: Math.max(size.x,size.y,size.z)*0.5 || 1e-6 };
}
function centerPivot(obj){ const {center} = bounds(obj); obj.position.sub(center); }
function normalizeScale(obj, target=1){
  const {radius} = bounds(obj);
  if (radius < 1e-6) return;
  if (radius < 0.001 || radius > 100) { const s = target / radius; obj.scale.setScalar(s); }
}
function fit(obj, pad=1.3){
  const {radius} = bounds(obj);
  const fov = camera.fov * Math.PI/180;
  const dist = (radius*pad)/Math.sin(fov/2);
  const dir = new THREE.Vector3(1,0.6,1).normalize();
  const c = new THREE.Vector3(); new THREE.Box3().setFromObject(obj).getCenter(c);
  controls.target.copy(c);
  camera.position.copy(c).addScaledVector(dir, dist);
  camera.near = Math.max(dist/1000, 0.001);
  camera.far  = dist*50 + radius*10;
  camera.updateProjectionMatrix();
}
function applyMaterial(obj){
  const mat = new THREE.MeshStandardMaterial({
    color:0xbec7d5, metalness:0.15, roughness:0.35, side:THREE.DoubleSide  // <- belangrijk
  });
  obj.traverse(o=>{ if(o.isMesh){ o.material = mat; }});
}
function scaleUnits(obj){ // probeer mm→m automatisch
  const {radius} = bounds(obj);
  if (radius > 1000) obj.scale.setScalar(0.001);    // mm → m
  if (radius < 0.001) obj.scale.setScalar(1000);    // µm → mm (noodgreep)
}

async function loadSTL(path){
  const loader = new STLLoader();
  return new Promise((res, rej)=>{
    loader.load(path, (geom)=>{
      if (!geom.hasAttribute('normal')) geom.computeVertexNormals();
      res(new THREE.Mesh(geom));
    }, undefined, rej);
  });
}

(async ()=>{
  try{
    const mesh = await loadSTL(MODEL);
    root.add(mesh);

    // robust pipeline
    scaleUnits(root);         // units guess (mm→m)
    normalizeScale(root, 1);  // bring to sane size
    centerPivot(root);
    applyMaterial(root);
    fit(root, 1.4);
  }catch(e){ alert('Model kon niet geladen worden: ' + (e?.message||e)); }
})();

document.getElementById('fit').onclick  = ()=> fit(root, 1.2);
document.getElementById('wire').onclick = ()=>{
  wire=!wire; root.traverse(o=>{ if(o.isMesh && o.material) o.material.wireframe = wire; });
};

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
(function anim(){ requestAnimationFrame(anim); controls.update(); renderer.render(scene,camera); })();
</script>
</body>
</html>
